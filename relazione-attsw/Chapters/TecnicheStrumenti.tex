\chapter{Tecniche e Framework utilizzati}

\section{Version Control System}

Per controllare il versionamento del software durante tutta la fase di sviluppo è stato utilizzato il software \textsl{git}, in congiunzione con la piattaforma \textsl{github}:
\begin{itemize}
	\item[Maven -] https://github.com/FrancescoTerrosi/rehearsal-room-project
	\item[Gradle -] https://github.com/FrancescoTerrosi/rehearsal-room-gradle
\end{itemize}

Nonostante il lavoro sia stato svolto da un singolo studente è stato comunque adottato il modello \textsl{gitflow}, accompagnato dai meccanismi di pull-request offerti da \textsl{github}, grazie ai quali è stato possibile effettuare vari check di integrità della build su \textsl{travis}, \textsl{coveralls} e \textsl{sonarcloud}.

\section{Build Automation}

Come già detto, sono stati usati due strumenti di build automation:
\begin{itemize}
	\item Maven: solido, conosciuto e ben accettato nell'ambiente di sviluppo software, data la sua diffusione vi sono molti tutorial, plugin e schemi di configurazione
	\item Gradle: molto recente, in continuo sviluppo, permette una configurazione pressoché totale della build del progetto
\end{itemize}

\subsection{Maven}

Le specifiche di un progetto Maven vengono definite nel file "pom.xml".\newline
All'interno di questo file è possibile definire alcune opzioni di configurazione del progetto (nome del gruppo e del progetto, versione di Java\dots) e, soprattutto, definire le dipendenze necessarie al corretto funzionamento del software e i plugin che specificano le operazioni da fare durante il processo di build.\newline
Per adottare una sorta di approccio modulare anche nel processo di build del progetto, sono stati definiti diversi profili all'interno del pom.\newline
Definire un profilo permette di incapsulare i plugin e le loro configurazioni al suo interno, in modo tale che queste vengano attaccate alla fase appropriata del lifecycle di Maven solamente quando richiesto.\newline
Per separare le operazione di generazione dei report di \textsl{JaCoCo}, i \textsl{Mutation Tests}, gli \textsl{Integration Tests} e gli \textsl{End to End Tests} sono stati quindi definiti i profili:
\begin{itemize}
	\item jacoco
	\item mutation
	\item integration
	\item e2e
\end{itemize}

\begin{minipage}{\linewidth}
	\includegraphics[width=\textwidth]{img/maven-goals.png}
	\captionof{figure}{Fasi e profili utilizzati per effettuare la build del progetto su travis-ci. Il profilo \textsl{mutation} non viene utilizzato in quanto di scarsa rilevanza per i check successivi (ma molto utile in locale)}
\end{minipage}
\newline

\subsection{Gradle}

Gradle è, attualmente, il maggior \textsl{competitor} di Maven per quanto riguarda la build automation.\newline
La procedura di assemblamento di un software è intrinsecamente diversa: se in Maven abbiamo un ciclo di vita rigido e ben definito, in cui i vari \textsl{goal} vengono eseguiti in un ordine ben definito e in maniera sequenziale, Gradle si basa sulla definizione di \textsl{tasks} (intuitivamente possiamo vederli come un corrispetivo dei \textsl{goal}), il cui ordine di esecuzione viene definito dal \textsl{task graph}, un grafo aciclico che definisce l'ordine di esecuzione dei vari compiti.\newline\newline
Il file in cui vengono definite le dipendenze del progetto, i plugin e altre configurazioni è il file "build.gradle". Uno dei vantaggi è indubbiamente l'utilizzo di un DSL \textsl{Groovy-like}, al posto del verboso xml utilizzato da Maven.\newline

\vspace{1cm}
\begin{minipage}{\linewidth}
	\includegraphics[width=\textwidth]{img/build-gradle.png}
	\captionof{figure}{Esempio di file build.gradle}
\end{minipage}

\pagebreak
Gradle permette inoltre di definire dei \textsl{task} personalizzati che possono essere inseriti all'interno del task graph (e quindi eseguiti ogni volta che viene eseguita la build del progetto. In questo caso possiamo immaginarli, con un certo livello di astrazione, come un \textsl{goal} di Maven che viene attaccato a una fase) oppure eseguirli in maniera autonoma.\newline\newline
Uno degli aspetti fondamentali nella definizione di nuovi task Gradle è la loro indipendenza. È buona pratica definire un file .gradle apposito in cui vengono dichiarati i \textsl{source sets} e le \textsl{dipendenze} necessarie al compimento del task, di modo tale che possa essere eseguito indipendentemente dagli altri.
È comunque possibile definire un ordinamento fra essi, utilizzando i comandi \textsl{dependsOn} e \textsl{finalizedBy}.\newline\newline
\vspace{1cm}
\begin{minipage}{\linewidth}
	\includegraphics[width=\textwidth]{img/itest-gradle.png}
	\captionof{figure}{Esempio di task definito dall'utente nel file itest.gradle}
\end{minipage}
\newline\newline
Un altro degli aspetti fondamentali di Gradle è il massiccio utilizzo del Gradle Wrapper.\newline
Il wrapper consente di poter effettuare build gradle senza averlo installato sulla propria macchina. Lavorando in team di sviluppo il vantaggio è ancora maggiore in quanto assicura che tutti i membri effettuino le build utilizzando la stessa versione di Gradle, senza bisogno di alcuna gestione aggiuntiva.\newline\newline
Tutti i plugin e le dipendenze Maven del progetto sono state ritradotte in Gradle, per assicurare l'uniformità delle due versioni. Su travis, la build viene eseguita con il seguente comando:\newline

\begin{minipage}{\linewidth}
	\includegraphics[width=\textwidth]{img/gradle-build.png}
	\captionof{figure}{Viene invocato il gradle wrapper per inizializzare la versione corretta di Gradle con cui eseguire la build del progetto}
\end{minipage}
\newline\newline
I task che vengono eseguiti sono:
\begin{itemize}
	\item build
	\begin{itemize}
		\item[$\rightarrow$] Configura la build e calcola il task graph, compila i file sorgente andando a scaricare le dipendenze, esegue i test e produce il fatjar dell'applicazione
	\end{itemize}
	\item jacocoTestReport
	\begin{itemize}
		\item[$\rightarrow$] Esegue JaCoCo per calcolare la code coverage
	\end{itemize}
	\item coveralls
	\begin{itemize}
		\item[$\rightarrow$] Cerca il file .xml prodotto da JaCoCo e invia i risultati a coveralls
	\end{itemize}
	\item sonarqube
	\begin{itemize}
		\item[$\rightarrow$] Effettua l'analisi su SonarCloud
	\end{itemize}
\end{itemize}
È possibile apprezzare come le operazioni per assemblare e testare effettivamente il progetto siano tutte racchiuse nel comando (task) \textsl{build}.

\section{Continuous Integration}

Per entrambi i progetti è stata stabilita un link con i server di Travis-CI, in modo tale da poter eseguire le build complete in remoto e poter continuare a lavorare localmente sul software.\newline
Le specifiche della build sono visualizzabili nel file .travis.yml, un file di configurazione che serve per dare direttive alla virtual machine su cui il progetto viene assemblato.\newline
Fra le due versioni vi è una piccola differenza: nel progetto Maven, i server MongoDB sono stati simulati attraverso l'utilizzo di Docker; per poterlo utilizzare sulla piattaforma di Travis è necessario specificarlo fra i servizi desiderati in modo tale che esso possa venire scaricato e successivamente eseguito dal plugin fabric8 in fase di testing.\newline
Nel progetto Gradle è stato invece utilizzato un plugin per avere un server MongoDB \textsl{embedded} nell'applicazione, pertanto non è stato necessario specificare l'utilizzo di Docker nel file .travis.

\section{Frameworks}

L'applicazione è stata sviluppata interamente utilizzando il framework \textsl{Spring Boot}, una delle varie soluzioni proposte dallo \textsl{Spring Framework} per la creazione di web-application in Java.\newline
L'utilizzo del framework in questione oltre ad utilizzare il meccanismo di inversione del controllo proprio di Spring, permette di sviluppare applicazioni web in maniera molto rapida, rispetto all'approccio tradizionale basato su servlet.\newline\newline
Uno degli aspetti più interessanti è appunto l'implementazione del meccanismo di \textsl{inversion of control} tramite la \textsl{dependency injection}. Dal momento che le applicazioni sviluppate con Spring Boot vengono eseguite in un web-container dove, al suo interno, viene a sua volta eseguito un server (Tomcat, in questo caso), utilizzando il meccanismo dei server embedded proprio di Spring.\newline\newline
Dal momento che risulta pressoché impossibile avere un controllo totale sull'istanziazione degli oggetti una volta che l'applicazione viene lanciata, il meccanismo di \textsl{dependency injection} è di estrema importanza. Nelle applicazioni Spring Boot, al momento del loro avvio, viene caricato un \textsl{application-context} in cui sono contenute tutte le informazioni relative ai \textsl{Bean} che non sono stati inizializzati. Attraverso l'utilizzo di questo \textsl{contesto} è possibile dunque iniettare i \textsl{Bean} nei vari oggetti al momento dell'inizializzazione dell'applicazione. Spesso è necessario definire dei file di \textsl{configurazione} per fornire informazioni aggiuntive sui Bean da creare.
\newline\newline
Un'altra importante \textsl{feature} offerta da Spring Boot sono le API per i server MongoDB. Attraverso la specifica di un semplice Bean (mongoTemplate) e la definizione dell'indirizzo IP e la porta su cui esso deve girare, è possibile connettersi al server e utilizzarlo in maniera molto intuitiva, grazie anche all'interfaccia MongoRepository.\newline
Altre feature degne di nota:
\begin{itemize}
	\item Thymeleaf: Template Engine utile per il rendering delle pagine HTML
	\item Spring-Security: Permette di implementare un meccanismo di autenticazione basato su Username e Password
\end{itemize}