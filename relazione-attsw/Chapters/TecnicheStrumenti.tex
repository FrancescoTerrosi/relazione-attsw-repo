\chapter{Tecniche e Framework utilizzati}

\section{Version Control System}

Per controllare il versionamento del software durante tutta la fase di sviluppo è stato utilizzato il software \textsl{git}, in congiunzione con la piattaforma \textsl{github}:
\begin{itemize}
	\item[Maven -] https://github.com/FrancescoTerrosi/rehearsal-room-project
	\item[Gradle -] https://github.com/FrancescoTerrosi/rehearsal-room-gradle
\end{itemize}

Nonostante il lavoro sia stato svolto da un singolo studente è stato comunque adottato il modello \textsl{gitflow}, accompagnato dai meccanismi di pull-request offerti da \textsl{github}, grazie ai quali è stato possibile effettuare vari check di integrità della build su \textsl{travis}, \textsl{coveralls} e \textsl{sonarcloud}.

\section{Build Automation}

Come già detto, sono stati usati due strumenti di build automation:
\begin{itemize}
	\item Maven: solido, conosciuto e ben accettato nell'ambiente di sviluppo software, data la sua diffusione vi sono molti tutorial, plugin e schemi di configurazione
	\item Gradle: molto recente, in continuo sviluppo, permette una configurazione pressoché totale della build del progetto
\end{itemize}

\subsection{Maven}

Le specifiche di un progetto Maven vengono definite nel file "pom.xml".\newline
All'interno di questo file è possibile definire alcune opzioni di configurazione del progetto (nome del gruppo e del progetto, versione di Java\dots) e, soprattutto, definire le dipendenze necessarie al corretto funzionamento del software e i plugin che specificano le operazioni da fare durante il processo di build.\newline
Per adottare una sorta di approccio modulare anche nel processo di build del progetto, sono stati definiti diversi profili all'interno del pom.\newline
Definire un profilo permette di incapsulare i plugin e le loro configurazioni al suo interno, in modo tale che queste vengano attaccate alla fase appropriata del lifecycle di Maven solamente quando richiesto.\newline
Per separare le operazione di generazione dei report di \textsl{JaCoCo}, i \textsl{Mutation Tests}, gli \textsl{Integration Tests} e gli \textsl{End to End Tests} sono stati quindi definiti i profili:
\begin{itemize}
	\item jacoco
	\item mutation
	\item integration
	\item e2e
\end{itemize}

\begin{minipage}{\linewidth}
	\includegraphics[width=\textwidth]{img/maven-goals.png}
	\captionof{figure}{Fasi e profili utilizzati per effettuare la build del progetto su travis-ci. Il profilo \textsl{mutation} non viene utilizzato in quanto di scarsa rilevanza per i check successivi (ma molto utile in locale)}
\end{minipage}
\newline

\subsection{Gradle}

Gradle è, attualmente, il maggior \textsl{competitor} di Maven per quanto riguarda la build automation.\newline
La procedura di assemblamento di un software è intrinsecamente diversa: se in Maven abbiamo un ciclo di vita rigido e ben definito, in cui i vari \textsl{goal} vengono eseguiti in un ordine ben definito e in maniera sequenziale, Gradle si basa sulla definizione di \textsl{tasks} (intuitivamente possiamo vederli come un corrispetivo dei \textsl{goal}), il cui ordine di esecuzione viene definito dal \textsl{task graph}, un grafo aciclico che definisce l'ordine di esecuzione dei vari compiti.\newline\newline
Il file in cui vengono definite le dipendenze del progetto, i plugin e altre configurazioni è il file "build.gradle". Uno dei vantaggi è indubbiamente l'utilizzo di un DSL \textsl{Groovy-like}, al posto del verboso xml utilizzato da Maven.\newline

\vspace{1cm}
\begin{minipage}{\linewidth}
	\includegraphics[width=\textwidth]{img/build-gradle.png}
	\captionof{figure}{Esempio di file build.gradle}
\end{minipage}

\pagebreak
Gradle permette inoltre di definire dei \textsl{task} personalizzati che possono essere inseriti all'interno del task graph (e quindi eseguiti ogni volta che viene eseguita la build del progetto. In questo caso possiamo immaginarli, con un certo livello di astrazione, come un \textsl{goal} di Maven che viene attaccato a una fase) oppure eseguirli in maniera autonoma.\newline\newline
Uno degli aspetti fondamentali nella definizione di nuovi task Gradle è la loro indipendenza. È buona pratica definire un file .gradle apposito in cui vengono dichiarati i \textsl{source sets} e le \textsl{dipendenze} necessarie al compimento del task, di modo tale che possa essere eseguito indipendentemente dagli altri.
È comunque possibile definire un ordinamento fra essi, utilizzando i comandi \textsl{dependsOn} e \textsl{finalizedBy}.\newline\newline
\vspace{1cm}
\begin{minipage}{\linewidth}
	\includegraphics[width=\textwidth]{img/itest-gradle.png}
	\captionof{figure}{Esempio di task definito dall'utente nel file itest.gradle}
\end{minipage}
\newline\newline
Un altro degli aspetti fondamentali di Gradle è il massiccio utilizzo del Gradle Wrapper.\newline
Il wrapper consente di poter effettuare build gradle senza averlo installato sulla propria macchina. Lavorando in team di sviluppo il vantaggio è ancora maggiore in quanto assicura che tutti i membri effettuino le build utilizzando la stessa versione di Gradle, senza bisogno di alcuna gestione aggiuntiva.\newline\newline
Tutti i plugin e le dipendenze Maven del progetto sono state ritradotte in Gradle, per assicurare l'uniformità delle due versioni. Su travis, la build viene eseguita con il seguente comando:\newline

\begin{minipage}{\linewidth}
	\includegraphics[width=\textwidth]{img/gradle-build.png}
	\captionof{figure}{Viene invocato il gradle wrapper per inizializzare la versione corretta di Gradle con cui eseguire la build del progetto}
\end{minipage}
\newline\newline
I task che vengono eseguiti sono:
\begin{itemize}
	\item build
	\begin{itemize}
		\item[$\rightarrow$] Configura la build e calcola il task graph, compila i file sorgente andando a scaricare le dipendenze, esegue i test e produce il fatjar dell'applicazione
	\end{itemize}
	\item jacocoTestReport
	\begin{itemize}
		\item[$\rightarrow$] Esegue JaCoCo per calcolare la code coverage
	\end{itemize}
	\item coveralls
	\begin{itemize}
		\item[$\rightarrow$] Cerca il file .xml prodotto da JaCoCo e invia i risultati a coveralls
	\end{itemize}
	\item sonarqube
	\begin{itemize}
		\item[$\rightarrow$] Effettua l'analisi su SonarCloud
	\end{itemize}
\end{itemize}
È possibile apprezzare come le operazioni per assemblare e testare effettivamente il progetto siano tutte racchiuse nel comando (task) \textsl{build}.

\section{Continuous Integration}

